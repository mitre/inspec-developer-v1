---
prev: ./3.md
next: ./5.md
---

## 4. Exploring the InSpec Shell

Before we test our NGINX configuration, let's plan which resources and matchers we'll need.

When writing InSpec code, many resources are available to you.

- You can [explore the InSpec documentation](https://www.inspec.io/docs/) to see which resources and matchers are available.
- You can [examine the source code](https://github.com/inspec/inspec) to see what's available. For example, you can see how file and other InSpec resources are implemented.
- You can also use examples, such as profiles provided on [Chef Supermarket](https://supermarket.chef.io/tools-directory), as a guide.

There's also [InSpec shell](https://www.inspec.io/docs/reference/shell/), which enables you to explore InSpec interactively. In this part, you'll use the InSpec shell to discover which resources you can use to test your NGINX configuration.

You're not required to use InSpec shell to develop your profiles. Some users find the InSpec shell to be a useful way to get immediate feedback and explore what's available. You can also use InSpec shell to debug your profiles.

### 4.1. Enter the shell

Run `inspec shell` to enter the interactive session.

```sh
inspec shell

Welcome to the interactive InSpec Shell
To find out how to use it, type: help

You are currently running on:

    Name:      ubuntu
    Families:  debian, linux, unix
    Release:   16.04
    Arch:      x86_64
```

Run `help` to see what commands are available.

```sh

inspec> help
    You are currently running on:

        Name:      ubuntu
        Families:  debian, linux, unix
        Release:   16.04
        Arch:      x86_64

    Available commands:

        `[resource]` - run resource on target machine
        `help resources` - show all available resources that can be used as commands
        `help [resource]` - information about a specific resource
        `help matchers` - show information about common matchers
        `exit` - exit the InSpec shell

    You can use resources in this environment to test the target machine.
```

Run `help resources` to see which resources are available.

```sh
inspec> help resources

         - aide_conf
         - apache
         - apache_conf
         - apt
         - audit_policy
         - auditd
         - auditd_conf
         ...
         - file
         ...
         - xml
         - yaml
         - yum
         - yumrepo
```

You see `file` and other resources listed.

### 4.2. Explore the file resource

Earlier, you saw this `describe` block...

```ruby
describe file('/tmp') do                  # The actual test
  it { should be_directory }
end
```

Let's run a few commands from the InSpec shell to see how the `file` resource works.

InSpec is built on the Ruby programming language. InSpec matchers are implemented as Ruby methods. Run this command to list which methods are available to the `file` resource.

```sh
inspec> file('/tmp').class.superclass.instance_methods(false).sort

        => [:allowed?,
         :basename,
         :block_device?,
         :character_device?,
         :contain,
         :content,
         :directory?,
         ...
         :sticky,
         :sticky?,
         :suid,
         :symlink?,
         :to_s,
         :type,
         :uid,
         :version?,
         :writable?]
```

You can use the arrow or Page Up and Page Down keys to scroll through the list. When you're done, press `Q`.

::: tip What is the InSpec Shell?
InSpec shell is based on a tool called pry. If you're not familiar with pry or
other REPL tools, later you can check out pry to learn more.
:::

As an example, call the `file.directory?` method.

```sh
inspec> file('/tmp').directory?
        => true
```

You see that the `/tmp` directory exists on your workstation container.

InSpec transforms resource methods to matchers. For example, the `file.directory?` method becomes the `be_directory` matcher. The `file.readable?` method becomes the `be_readable` matcher.

The InSpec shell understands the structure of blocks. This enables you to run mutiline code. As an example, run the entire `describe` block like this.

```sh
inspec> describe file('/tmp') do
inspec>  it { should be_directory }
inspec> end
        Profile: inspec-shell
        Version: (not specified)

          File /tmp
             ✔  should be directory

        Test Summary: 1 successful, 0 failures, 0 skipped
```

In practice, you don't typically run controls interactively, but it's a great way to test out your ideas.

A Ruby method that ends in `?`, such as `directory?` is known as a predicate method. The `?` syntax is intended to make Ruby code easier to read.

A predicate method typically returns a value that can be evaluated as true or
`false`. In Ruby, false and nil are false; everything else evaluates to `true`.

### 4.3. Explore the nginx resource

Now's a good time to define the requirements for our NGINX configuration. Let's say that you require:

```
1. NGINX version 1.10.3 or later.
2. the following NGINX modules to be installed:
   * `http_ssl`
   * `stream_ssl`
   * `mail_ssl`
3. the NGINX configuration file, `/etc/nginx/nginx.conf`, to:
   * be owned by the `root` user and group.
   * not be readable, writeable, or executable by others.

```

Let's see what resources are available to help define these requirements as InSpec controls.

Run `help resources` a second time. Notice InSpec provides two built-in resources to support NGINX – `nginx` and `nginx_conf`.

```sh
inspec> help resources

         - aide_conf
         - apache
         - apache_conf
         - apt
         ...
         - nginx
         - nginx_conf
         ...
         - xml
         - yaml
         - yum
         - yumrepo
         - zfs_dataset
         - zfs_pool
```

Run `nginx.methods`. You see the `version` and `modules` methods. You'll use these methods to define the first two requirements.

```sh
inspec> nginx.class.superclass.instance_methods(false).sort

        => [:bin_dir,
         :compiler_info,
         :error_log_path,
         :http_client_body_temp_path,
         :http_fastcgi_temp_path,
         :http_log_path,
         :http_proxy_temp_path,
         :http_scgi_temp_path,
         :http_uwsgi_temp_path,
         :lock_path,
         :modules,
         :modules_path,
         :openssl_version,
         ...
         :to_s,
         :version]
```

Run `nginx.version` to see what result you get.

```sh
inspec> nginx.version

        NoMethodError: undefined method `[]' for nil:NilClass
        from /opt/inspec/embedded/lib/ruby/gems/2.4.0/gems/inspec-2.0.17/lib/resources/nginx.rb:39:in `block (2 levels) in <class:Nginx>'
```

Notice the error. This tells us that NGINX is not installed. Recall that you're working on your workstation container environment, which does not have NGINX installed. Run the following [package](https://www.inspec.io/docs/reference/resources/package/) resource to verify.

```sh
inspec> package('nginx').installed?

        => false
```

Although you've discovered the methods you need – `version` and `modules` – let's run InSpec shell commands against the target that does have NGINX installed to see what results we find. To do so, first start by exiting your InSpec shell session.

```
inspec> exit
```

Run `inspec shell` a second time. This time, provide the `-t` argument to connect the shell session to the target container. This is similar to how you ran `inspec exec` in the [Try InSpec](https://learn.chef.io/modules/try-inspec#/step4.3) module to scan the target from the workstation.

```sh
inspec shell -t docker://DOCKER_CONTAINER_ID

  Welcome to the interactive InSpec Shell
  To find out how to use it, type: help

  You are currently running on:

      Name:      ubuntu
      Families:  debian, linux, unix
      Release:   16.04
      Arch:      x86_64
```

Remember that the target does not have the InSpec CLI installed on it. Your shell session exists on the workstation container; InSpec routes commands to the target instance over Docker.

Run the `package` resource a second time, this time on the target container.

```
inspec> package('nginx').installed?

        => true
```

You see that NGINX is installed. Now run `nginx.version`.

```
inspec> nginx.version

        => "1.10.3"
```

You see that version 1.10.3 is installed. To complete the example, run `nginx.modules` to list the installed NGINX modules.

```
inspec> nginx.modules

        => ["http_ssl",
         "http_stub_status",
         "http_realip",
         "http_auth_request",
         "http_addition",
         "http_dav",
         "http_geoip",
         "http_gunzip",
         "http_gzip_static",
         "http_image_filter",
         "http_v2",
         "http_sub",
         "http_xslt",
         "stream_ssl",
         "mail_ssl"]
```

You see that the required modules, `http_ssl`, `stream_ssl`, and `mail_ssl`, are installed.

The [nginx_conf](https://www.inspec.io/docs/reference/resources/nginx_conf/) resource examines the contents of the NGINX configuration file, `/etc/nginx/nginx.conf`.

Recall that the third requirement is to check whether the NGINX configuration file is owned by `root` and is not readable, writeable, or executable by others. Because we want to test attributes of the file itself, and not its contents, you'll use the `file` resource.

You saw earlier how the `file` resource provides the `readable`, `writeable`, and `executable` methods. You would also see that the `file` resource provides the `owned_by` and `grouped_into` methods.

```
inspec> file('/tmp').class.superclass.instance_methods(false).sort

        => [:allowed?,
         :directory?,
         :executable?,
         :exist?,
         :file,
         :file?,
         :file_version,
         :gid,
         :group,
         :grouped_into?,
         ...
         :owned_by?,
         ...
         :readable?,
         ...
         :to_s,
         :type,
         :uid,
         :version?,
         :writable?]
```

These 5 `file` methods – `grouped_into`, `executable`, `owned_by`, `readable` and `writeable` – provide everything we need for the third requirement.

Exit the InSpec shell session.

```
inspec> exit
```
